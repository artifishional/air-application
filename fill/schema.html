<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title></title>

    <link rel="stylesheet" href="styles/main.css" type="text/css"/>

    <script src = "m2.js"></script>


    <style>

        .title {

            color: white;

            font-size: 50px;

        }

        .description {
            max-width: 700px;
            font-family: Verdana, sans-serif;
        }

        .content {

            padding: 25px;

        }

        .block {
            padding-top: 25px;
            color: white;
            font-size: 20px;
        }

        .action:before {
            padding-right: 10px;
            float: left;
            font-size: 25px;
            color: mediumvioletred;
            content: "action:";
        }

        .request:before {
            padding-right: 10px;
            float: left;
            font-size: 25px;
            color: mediumvioletred;
            content: "request:";
        }

        .block .name {
            font-size: 25px;
            color: mediumvioletred;
            text-decoration: underline;
        }

        .block pre {
            padding: 20px;
        }

        .block code {
            display: block;
            border-left: 1px solid mediumvioletred;
            padding: 10px;
            padding-left: 30px;
            font-size: 15px;
        }

        .block .desc {
            text-align: justify;
            padding: 10px;
            padding-top: 20px;
            color: white;
            font-size: 15px;
        }

        .block .format {

        }

    </style>

</head>
<body>

    <svg id = "schema-tree" viewBox = "-1440 -100 2159 1250" width="100%" height="100%">

        <defs>
            <filter id="dropshadow">
                <feDropShadow dx="0" dy="0" stdDeviation="6"/>
            </filter>
        </defs>

    </svg>

</body>
</html>

<script>

    const {pow} = Math;

    function schemaToTreant([key, {type, source, linkers, ...args}, ...schema]) {
        const children = schema.map(ch => schemaToTreant(ch));
        return {
            text: {name: `${JSON.stringify(key)}` + (linkers.length ? `: ${linkers.length}` : "") },
            children,
            HTMLclass: (linkers.length ? "use" : "clean") + (typeof source === "function" ? " source": "")
        }
    }


    const svg = (type, { style = {}, text, class: className, ...attr } = {}, ...nodes) => {
        const src = document.createElementNS("http://www.w3.org/2000/svg", type);
        className && (src.className.baseVal = className);
        if(text) {
            if(text.split("\n").length > 1) {
                text.split("\n").map( (text, i, arr) => src.append( svg( "tspan", { text, x: 0, dy: !i ? "-0.5em" : "1.1em" } ) ) );
            }
            else {
                src.textContent = text;
            }
        }
        Object.keys(style).map( key => src.style[key] = attr[key] );
        Object.keys(attr).map( key => src.setAttribute(key, attr[key]) );
        nodes.filter(n=>n).map( ch => src.append(ch) );
        return src;
    };

    const dom = (type, { style = {}, text, class: className, ...attr } = {}, ...nodes) => {
        const src = document.createElement(type);
        className && (src.className = className);
        if(text) {
            src.innerHTML = text;
        }
        Object.keys(style).map( key => src.style[key] = attr[key] );
        Object.keys(attr).map( key => src.setAttribute(key, attr[key]) );
        nodes.filter(n=>n).map( ch => src.append(ch) );
        return src;
    };

    class Description {

        constructor() {
            this.layer = dom( "div", { class: "outer" },
                this.fader = dom( "div", { class: "fader" } ),
                this.description = dom( "div", { class: "description" },
                    this.content = dom("div"),
                ),
            );
            this.fader.addEventListener("click", this);
        }

        send( { title, blocks }, { dir } ) {

            if(dir === "left") {
                this.description.style.left = "0px";
                this.description.style.right = "";
            }
            else {
                this.description.style.right = "0px";
                this.description.style.left = "";
            }

            this.layer.style.display = "block";
            setTimeout(()=> this.fader.classList.add("fade"));
            let content;
            this.description.replaceChild(
                content = dom( "div", { class: "content" },
                    dom( "div", { class: "title", text: title } ),
                    ...blocks.map( ({ name, type, desc, format }) => dom( "div", { class: "block " + type },
                        dom( "div", { class: "name", text: type === "action" ? `[${name}]` : name }),
                        desc && dom( "div", { class: "desc", text: desc }),
                        format && dom( "div", { class: "format" },
                            dom( "pre", {},
                                dom( "code", { class: "jsx", text: format }),
                            ),
                        ),
                    ) )
                ),
                this.content
            );
            this.content = content;
        }

        handleEvent() {
            this.fader.classList.remove("fade");
            this.layer.style.display = "none";
        }

    }

    function parser(source, key) {
        const description = (source.match(/\/\*\*[\s\S]*?\*\//gm) || [ "" ]).join("");
        const [, title] = description.match(/\@name ([\w\-\d]*)/) || [0, key];
        const res = [];
        if(description) {
            const reg = /\@(action|request) ([\S\-\d]*)\s*(?:\@description([^@]*)){0,}\s*(?:\@format\s*([^@]*)){0,}/gm;
            let cur = [];
            while ((cur = reg.exec(description.replace(/\/\*|[ \t]*\*\/|[ \t]*\*/gm, ""))) !== null) {
                res.push( {
                    type: (cur[1] || "action").trim(),
                    name: (cur[2] || "").trim(),
                    desc: (cur[3] || "").trimRight()
                        .replace(/\</g, "&lt;")
                        .replace(/\>/g, "&gt;")
                        .replace(/\n/g, "<br/>")
                        .replace(/\s/g, "&ensp;"),
                    format: (cur[4] || "").trim(),
                } );
            }
        }
        return { title, blocks: res };
    }

    class Vertex {

        constructor( { id, key, source = null, linkers = [], lead = true }, description ) {
            this.lead = lead;
            this.key = key;
            this.children = [];
            this.description = description;
            this.source = source;
            this.id = id;
            this.layer = svg("g", { class: "layer" },
                this.inner = svg("g", { class: "inner" },
                    svg( "g", { class: "model" },
                        this.path = svg( "path", { class: "arrow", d: "M0 0 L0 -200" } ),
                        this._main = svg( "g", { },
                            this._selected = svg( "g", {},
                                svg( "ellipse", { class: "el3", rx: 48, ry: 48 } ),
                                svg( "ellipse", { class: "el2", rx: 48, ry: 48 } ),
                                svg( "ellipse", { class: "el1", rx: 48, ry: 48 } ),
                            ),
                            this.ellipse = svg( "ellipse", { class: "ellipse" + (source ? " source" : ""), rx: 50, ry: 50 } ),
                            svg( "text", { "text-anchor": "middle", text: key } ),
                            svg( "g", {},
                                this._counter = svg( "ellipse", { class: "counter", cx: 36, cy: 36, rx: 24, ry: 24 }),
                                this._counterval = svg( "text", { x: 36, y: 36, "text-anchor": "middle", text: "" } ),
                            )
                        )
                    ),
                ),
            );
            this._main.addEventListener("click", this);
            this.select(linkers);
        }

        handleEvent({type, currentTarget}) {
            if(type === "click") {

                const {x} = currentTarget.getBoundingClientRect();
                const dir = x < document.body.offsetWidth / 2 ? "right": "left";

                if(this.source) {
                    this.description.send( this.source, { dir } );
                }
            }
        }

        select( linkers ) {
            this._counter.style.display = ["none", ""][+(!!linkers.length)];
            this._counterval.textContent = linkers.length || "";
            this._selected.style.display = ["none", ""][+(!!linkers.length)];
        }

        fill( childrens) {
            childrens.map( ([key, { source = null, linkers, id }, ...childrens]) => {

                source = typeof source === "function" ? parser(source.toString(), key) : null;

                let exist = this.children.find( ({ id: x }) => x === id );
                if(!exist) {
                    const _key = JSON.stringify(key)
                        .replace(/[\{\}\"]/g, "")
                        .replace(":", ":\n");
                    exist = new Vertex(
                        { linkers, key: _key, id,
                            source,
                            lead: false},
                        this.description
                    );
                    this.add( exist );
                }
                exist.select( linkers );
                exist.fill( childrens );
            } );
            if(!this.lead) {
                const len = 180 + this.children.length * 40;
                this.path.setAttribute( "d", `M0 0 L0 -${len}` );
                this.inner.style.transform = `translateY(${len}px)`;
            }
            this._main.style.transform = `scale(${this.children.length*0.1 + 0.9})`;
            getComputedStyle(this.inner).opacity;
        }

        setparent(parent) {
            parent.inner.prepend(this.layer);
        }

        add( vertex ) {
            vertex.setparent(this);
            this.children.push(vertex);
            this.children.map( ({ layer, inner, path }, i, arr) => {
                const angle = -140 + 280 / (arr.length + 1) * (i+1);
                inner.style.opacity = 0;
                getComputedStyle(inner).opacity;
                inner.style.opacity = 1;
                layer.style.transform = `rotate(${angle}deg)`;
            } );
        }


    }

    const description = new Description();
    const tree = document.querySelector("svg");
    const main = new Vertex( { key: "$" }, description );
    tree.append(main.layer);
    document.querySelector("body").append(description.layer);

    function render() {
        main.fill(modelschema.toSCHEMA().slice(2));
    }

    setInterval(render, 500);


</script>